<font size=7>Golang Basic Knowledge</font><br>





12.
golang的map涉及到两个底层结构体——hmap和bmap
bmap也叫bucket，bucket就是存储数据的键—值的数据结构，底层采用链表形式存储，每个bmap中还会存储一个overFlow指针，用于扩容时指向下一个bmap
![](_v_images/20220515214029111_10820.png =769x)


13.
设计者有意为之，因为map有双倍扩容和等量扩容两种方式，在等量扩容后，key可能从原有的桶移动到另外的桶中
如果想有序遍历，把所有key拿出来排序就行了，空间与时间复杂度都是N

14.
直接对基本的map进行多协程操作，会触发panic
并发安全的map，直接使用sync.Map就行

15.
在要查找的对象不存在时，第一个出参是对应类型的0值，第二个出参是false
d, ok := m["key"]
d := m["key"]
基本查找时，用hash的低B位定位桶的位置，用高8位来定位桶内key的位置，过程如下：
![](_v_images/20220515221357439_19545.png =883x)


16.
空间换时间，相当于为map多封装了一个read变量和互斥锁，适用于读多写少的场景
type Map struct {
   mu Mutex
   read atomic.Value // readOnly
   dirty map[interface{}]*entry
   misses int
}

17.
channel有两种类型：有缓冲和无缓冲
channel有三种模式：读通道、写通道和
![](_v_images/20220515224258260_26700.png =552x)
channel有三种状态：未初始化、关闭和正常开启
![](_v_images/20220515224337870_31728.png =748x)
一个 channel不能多次关闭，会导致painc
如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费
如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号



18.从设计的角度，channel本来使用的场景就是多协程，所以必须支持线程安全
channel的底层采用了Mutex来保证读写安全


19.
无论是通过共享内存来通信还是通过通信来共享内存，最终我们应用程序都是读取的内存当中的数据，只是前者是直接读取内存的数据，而后者是通过发送消息的方式来进行同步。而通过发送消息来同步的这种方式常见的就是 Go 采用的 CSP(Communication Sequential Process) 模型
![](_v_images/20220515225440948_14124.png =888x)
大部分的语言采用的都是第一种方式直接去操作内存，然后通过互斥锁，CAS 等操作来保证并发安全。Go 引入了 Channel 和 Goroutine 实现 CSP 模型将生产者和消费者进行了解耦，Channel 其实和消息队列很相似。
优点：使用 channel 可以帮助我们解耦生产者和消费者，可以降低并发当中的耦合
缺点：容易出现死锁的情况





